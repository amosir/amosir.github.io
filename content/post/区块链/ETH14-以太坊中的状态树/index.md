---
title: "ETH14 以太坊中的状态树"
date: 2023-05-28T13:50:04+08:00
draft: true
image: ""
categories: 
tag:
---


> 整理自 [北京大学肖臻老师《区块链技术与应用》公开课](https://www.bilibili.com/video/BV1Vt411X7JF?from=search&seid=14488407572640514229)

要完成的功能: **账户地址到账户状态的映射(addr-->state)** 。以太坊中的账户地址是160bits，一般表示成 40个十六进制的数。可以通过哪些数据结构实现呢?

1. **hash table**？怎样提供merkle proof，证明账户余额？把哈希表中的元素组织成merkle tree，算出root hash，保存在block header。问题在于有新区块发布，新区块中有新的交易，执行这个交易，必然会使哈希表中的内容发生变化，如果把哈希表中的内容重新组织成一棵merkle tree，代价大(实际上真正发生变化的账户状态只是一小部分，只是区块中包含的交易所关联的账户发生变化)
   比特币中也是每出一个区块就构造一棵merkle tree，但是merkle tree构建完之后是不会再改的，下次再发布一个新的区块就构建一棵新的merkle tree。以太坊中如果把所有的账户构建成一棵merkle tree，每次修改都要遍历所有账户并重构merkle tree，这样的代价就会很大，不可行。merkle tree另一个作用是维护各个全节点状态的一致性。

2. **merkle tree**？1) .没有提供一个高效的查找和更新的方法。2) .不排序产生的问题，查找代价大，叶节点是账户的信息，如果不规定账户在叶节点中的顺序，那么构建的merkle tree不唯一，算出的root hash不一样。
比特币中也是不排序，根哈希不唯一，每个全节点收到交易的顺序也不一样，但是是最后获得记账权的节点说的算。每个节点在本地组装一个候选区块，节点自己决定哪些交易被打包到区块以及什么样的顺序打包，然后去争夺记账权，如果没争夺到记账权，什么样的决定别人没必要知道。如果以太坊也这么做，那么就需要把账户的状态发布到区块里(不然别的节点就没法知道账户的状态)，每个全节点自己决定怎么把账户及状态组织成merkle tree并算出root hash，等到挖出矿发布出去。但是发布的是所有账户的状态，不是新区块中包含的交易，大部分账户状态是不变的，每十几秒打包所有账户状态发布一遍，大部分账户都重复发布，不可行。

3. **sorted merkle tree**？新增一个账户产生的账户地址是随机的，插入数据代价大，不可行。

在讲以太坊使用的数据结构之前先看一下 **Trie(字典树)**

**优点:**

1. 每个节点的分支数目取决于key值里每个元素的取值范围。用Trie表示小写的英文单词时，每个节点的分支数目是26个，加上1个结束标志位。以太坊中地址表示成40个16进制的数，所以分支数目是17(0~f加上结束标志符)。
2. 查找效率取决于key长度，键值越长，查找需要访问内存的次数就越多。以太坊key值都是一样长的，长度是40。
3. 哈希表理论上会出现哈希碰撞，Trie不会出现碰撞，只要两个地址不一样，肯定会映射到不同分支。
4. 只要输入不变，无论什么顺序插入，最后插入到Trie中构成的是同一棵树。
5. 每发布一个区块，系统中绝大多数账户的状态是不变的，只有个别受到影响的账户的状态才会变。如果要修改某个分支key的value，只需要访问特定分支，其他分支无需访问，也无需遍历整棵树，所以更新操作的局部性好。

**缺点**:

存储浪费。

有些节点只有一个子节点，如果这些节点能够合并，就能够减少存储的开销，同时也提高查找效率。

<img src="https://gitee.com//tiansir-wg/blogimg/raw/master/imgs/20200612133957.png" alt="image-20200612133957294" style="zoom:50%;" />

下面引入**Patricia tree(trie)**，即经过路径压缩的前缀树

<img src="../../../../Library/Application Support/typora-user-images/image-20200612134207451.png" alt="image-20200612134207451" style="zoom:50%;" />

如果新插入一个分支，原来压缩的路径可能需要扩展开。树中插入的键值的分布如果是比较稀疏的情况下，做不做路径压缩效果差距比较大。以太坊中的键值分布是160bits的地址，整个空间是$2^{160}$，是非常稀疏的。因为可以减少哈希碰撞的概率，地址足够长，分布足够稀疏，这是一个去中心化的系统防止账户冲突的唯一办法。



**(MPT)Merkle Patricia tree**

与Patricia Tree的区别是: **<u>用哈希指针替换普通指针</u>**

所有的账户组织成一个patricia tree，用路径压缩提高效率，然后把普通指针换成哈希指针，所以可以算出root hash，写在block header中。这样可以: 1.防止篡改，每个账户的状态都能保证没有被篡改。2.merkle proof。证明账户余额有多少，证明MPT中某个键值不存在。

**以太坊使用的是Modified MPT**

系统中每个全节点需要维护的不是一棵MPT，而是每次出现一个区块都要新建一个MPT，只不过这些状态树中大部分的节点是共享的，只有少数发生变化的节点要新建分支。

<img src="https://gitee.com//tiansir-wg/blogimg/raw/master/imgs/20200612143103.png" style="zoom:50%;" />



> 为什么保留历史状态，不在原地直接修改？

以太坊把出块时间降到十几秒之后，临时性分叉的出现是常态，假设有一个分叉，两个节点同时获得记账权，两个节点最终会有一个胜出，没有胜出的节点则回滚到上一个区块的状态。如何实现回滚呢? 比特币可以推算出前一个状态，转账交易回滚比较容易。以太坊中有智能合约，如果不保存之前的状态，在智能合约执行完之后，想再推算出之前的状态是不可能的，所以要实现回滚，必须要保存历史状态。

