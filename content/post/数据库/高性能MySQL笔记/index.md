---
title: "高性能MySQL笔记"
date: 2022-03-28T14:09:59+08:00
draft: false
image: "img/Cy5dya5MAlI.jpg"
categories: 
tag:
---

# MySQL 架构

## MySQL 逻辑结构

**连接器：用于链接处理、权限验证、安全等**

**解析器、优化器：负责 MySQL 查询解析、分析、优化、缓存、内置函数实现、存储过程、视图、触发器等**

**存储引擎：负责 MySQL 数据的存储和提取（通过 API 来屏蔽不同存储引擎的差异）**

## 并发控制

### 读写锁

读锁（共享锁）：自己可读不可写，别人可读不可写

写锁（排它锁）：自己可读可写，别人不可读不可写

### 锁粒度

表锁：MySQL 最基本的锁策略，锁表，开销最小**（MySQL 本身就可以使用，而不需要存储引擎处理）**

页锁：

行锁：MySQL 最细的锁策略，锁行，开销最大**（MySQL 本身并不支持，需要存储引擎支持）**

### 事务

**原子性（A）：整个事务要么都执行，要么都不执行**

**一致性（C）：数据库一定是从一个一致性的状态到另一个一致性的状态**

**隔离性（I）：两个事务之间相互隔离**

**持久性（D）：事务一旦提交，即使系统崩溃，事务的更新也不会消失**

### 隔离级别

通过 SET TRANSACTION ISOLATION LEVEL 来设置隔离级别

**READ UNCOMITTED（未提交读）：导致脏读、不可重复读、幻读**

**READ COMMITTED（提交读）：导致不可重复读、幻读**

**REPEATABLE READ（可重复读）：导致幻读（MySQL 默认隔离级别）**

**SERIALIZABLE（串行化读）：强制事务串行执行**

### 死锁

**MySQL 死锁解决方案：持有最少行级排它锁的事务回滚**

**锁的行为和存储引擎有关，同样的顺序执行语句，有的存储引擎就可能死锁，有的就不会**

### 隐式锁定与显式锁定

在事务执行的时候，会自动进行隐式锁定，只有在 COMMIT 或者 ROLLBACK 的时候才会释放

**SELECT .... LOCK IN SHARE MODE \ FOR UPDATE 在服务器层实现了显式锁定**

## 多版本控制

包括 MySQL、Oracle 等数据库都实现了 MVCC

**MVCC 可以认为是行级锁的变种，实现了非阻塞的读操作和更快的写操作**

MVCC 的实现是通过保存数据在某个时间点的快照来实现的，即根据事务开始时间的不同，每个事务看到的表都不同

InnoDB 的 MVCC，是通过在每行后面记录两个特殊的列来实现的：行的创建版本号、行的过期版本号

**如在 REPEATABLE READ 的隔离级别下：**

- **SELECT 操作会只查找 创建版本号早于当前事务版本、过期版本号晚于当前事务的数据行**
- **INSERT 操作会保存当前系统版本号为创建版本号**
- **DELETE 操作会保存当前系统版本号为删除版本号**
- **UPDATE 操作会保存当前系统版本号为新纪录的创建版本号，并 保存当前系统版本号为原纪录的删除版本号**

## 存储引擎

MySQL 将每个数据库（schema）保存为数据库录下的一个子目录

**通过与表同名的 *****xxx.frm***** 文件保存表的定义**

可以通过 `SHOW TABLE STATUS LIKE ‘table_name’` 来显示表的信息

- 表信息
    - Name：表名
    - Engine：存储引擎
    - Row_Format：Dynamic（可变）、Fiex（固定）、Comparessed（压缩表）
    - Rows：行数（InnoDB 为估计值）
    - Avg_row_length：平均每行字节数
    - Data_length：表数据大小（字节）
    - Max_data_length：最大容量（字节）
    - Index_Length：索引大小（字节）
    - Data_free：已分配但没使用的空间（字节）
    - Auto_increment：下一个 AUTO_INCREMENT 的值
    - Create_time：创建时间
    - Update_time：最后修改时间
    - Check_time：最后一次使用 CHECK TABLE 命令时间
    - Collation：表的默认字符集和字符列排序规则
    - Create_options：创建表时指定的其它选项
    - Comment：其它的信息（MyISAM 保存了注释、InnoDB 保存了表空间的剩余空间信息）

# MySQL 测试

# MySQL 表设计

## 数据类型的选择

1. **更小的通常更好（在保证没有低估的情况下，使用尽量小的数据类型）**
2. **越简单越好（整形比字符串简单、MySQL 的 DATETIME 比字符串简单）**
3. **尽量避免 NULL（使用 NULL 难以优化，但是无所谓通常）**

### 整数类型

TINYINT < SMALLINT < MEDIUMINT < INT < BIGINT

**整数计算一般使用 64 位的 BITINT 进行计算**

**MYSQL 可以为整数指定宽度，但这通常没有意义**

### 实数类型

FLOAT < DOUBLE < DECIMAL

**CPU 本身不支持 DECIMAL 的直接计算，所以 MySQL 是通过服务器自身来支持 DECIMAL 计算，所以 FLOAT 和 DOUBLE 的计算要比 DECIMAL 计算快很多**

**DECIMAL 通过将数字打包进一个二进制字符串中，每 4 个字节存储 9 位数字，小数点本身占一个字节**

### 字符串类型

CHAR、VARCHAR

VARCHAR 会使用 1~2 个额外字节记录字符串的长度

如果使用了 ROW_FORMAT = FIXED，则每一行都会使用定长的存储，比较浪费空间

使用 CHAR 来保存一些固定长度的值，如 MD5

当 **VARCAHR 在页中没有更多的空间可以存储，MyISAM 会将行拆成不同的片段存储，InnoDB 会分裂页让行放入页内**

**当 VARCHAR 过长时，InnoDB 会将其存储为 BLOB 格式**

**我们在分配 VARCHAR 的时候要尽量在合理范围内，不要过长**

### BLOB 与 TEXT

TINYTEXT < SMALLTEXT = TEXT < MEDIUMTEXT < LONGTEXT

TINYBLOB < SMALLBLOB = BLOB < MEDIUMBLOB < LONGBLOB

**MySQL 会将 BLOB 和 TEXT 当做一个独立的对象处理，当特别大的时候，会单独使用”外部“存储区域来进行存储，然后行内使用一个 1~4 字节的指针**

**BLOB 存的是二进制数据，没有排序规则和字符集，而 TEXT 则有，但是只能对数据的前 max_sort_length 进行排序**

### ENUM

枚举类型可以用来含有固定的字符串的地方

### 时间类型

DATETIME、TIMESTAMPE

**DATETIME 记录 1001~9999 年，精度为秒，会将日期封存在 YYYYMMDDHHMMSS 的整数中**

**TIMESTAMP 记录 UNIX 时间戳，精度为秒，并且会根据时间进行记录，但最多记录到 2038 年**

### BIT

**MySQL 5.0- 的时候，BIT 是 TINYINT 的同义词**

**MySQL 5.0+ 的时候，BIT(n) 可以存储 n 个位**

**MyISAM 会打包所有的 BIT，来单独存储，而 InnoDB 会为每个 BIT 列使用一个单独的 TINYINT 存储，所以不能节省空间**

**MySQL 会将 BIT 当做字符串类型，所以其中的 0 和 1 是字符串，而不是 ASCII 的 0 和 1，而我们使用的时候则会进行转换**

```sql
CREATE TABLE bittest(a bit(8));
INSERT INTO bittest VALUES(b'00111001'); // 00111001 = 57
SELECT a, a+0 FROM bittest;
+-----+---------+
|  a  |  a + 0  |
+-----+---------+
|  9  |    57   |
+-----+---------+
```

## 主键选择

主键使用整数是最好的选择，在速度方面很快并且可以使用 AUTO_INCREMENT

**当然在其基础上因为存在分布式，所以可以采用雪花id、Leaf ID 等**

**尽量不使用字符串，甚至随机的字符串（UUID、MD5）来作为 PK，他们不仅会造成索引碎片，页分裂，海慧造成 SELEFCT 语句变慢，局部性原理失效等等问题**

## 表结构设计的陷阱

- **避免太多的列**
**在 MySQL 存储引擎工作的时候（服务器层与存储引擎层）之间会将行缓冲格式拷贝数据，然后在服务器层将行缓冲解码为各个列，如果列过多，则解码的操作会带来代价**
- **太多的关联**
**MySQL 最多只能由 61 张表关联**
**我们查询中最多不要超过 12 个表（阿里巴巴 Java 规范不得超过 6 个）**
- 全能的枚举、变相的枚举（过度使用枚举、过度使用 SET）
- **非此发明的 NULL**
**不要为了 NOT NULL 而 NOT NULL**

## 范式与反范式

- 范式化的更新操作通常比反范式化要快
- 范式化的执行操作更快
- 范式化可能需要较多的查询，可能需要较多的关联操作，造成更多的 随机 IO

## 物化视图

**物化视图指的是预先计算并存储在磁盘上的表，可以通过各种各样的策略进行刷新或者更新**

**MySQL 本身不会支持物化视图，可以通过开员工及来实现**

## ALTER TABLE 的速度

1. 在一台不提供服务的机器上执行 ALTER TABLE，然后和提供服务的主库进行切换
2. 使用一张新表，之后通过重命名和删表操作进行交换
3. **只修改 .frm 文件而不是复制所有数据**
手工更新 frm 文件
**不需要重建表的操作**

```sql
ALTER TABLE film MODIFY COLUMN rental_limit_days TINYINT(3) NOT NULL DEFAULT 5;
// 通过 SHOW STATUS 表示这句 SQL 通过拷贝了一张新表来进行
// 但是我们可以使用
ALTER TABLE film ALTER COLUMN rental_limit_days SET DEFAULT 5;
// 这样就可以直接修改 .frm 而不是设计表数据 
```

```sql
// 锁定表
FLUSH TABLES WITH READ LOCK
// 放开表
UNLOCK TABLES
```
    - **移除一个列的 AUTO_INCREMENT 属性（添加不行）**
    - **增加、删除、修改 ENUM 和 SET 常量**

### 索引与修改数据

**对于大范围的修改数据，可以先删除所有的非唯一索引，然后添加新的咧，最后重新创建删除的索引**

# MySQL 索引设计

## 索引分类

### B+ 树索引

### 哈希索引

**哈希索引基于哈希表实现，只有精准匹配索引所有的列的查询才有效**

**对于读多写少的数据，可以通过在插入的时候添加 Hash 值来使用 Hash 查询，而不是 B+ 树查询**

### R-Tree 索引

### 全文索引

**InnoDB 支持全文索引**

**MyISAM 的全文索引是一种特殊的 B-Tree 索引，第一层是所有的关键字，第二层是每个关键字对应的相关的文档指针**

## 高性能索引策略

1. **使用索引的时候使用独立的列，而不要使用函数（如：TO_DAYS()）和表达式（如：actor_id + 1 = 5）**
2. **注意最左匹配原则和索引下推**
3. **针对很长的列使用前缀索引（同上适用于不需要 ORDER 和 GROUP 并且需要索引的地方（UUID 等））**

### 合并索引（Using union）

```sql
SELECT * FROM users WHERE age > 18 OR height > 180
```

**在 MySQL 5.0- 的时候会进行全表扫描**

**在 MySQL 5.0+ 的时候会扫描两个单列索引，并进行合并**

```sql
// 即类似于
SELECT * FROM users WHERE age > 18
UNION
SELECT * FROM users WHERE height > 180
```

同样，对于 AND，MySQL 就会使用 INTERSECT

### 聚簇索引

注意如何实现不需要回表的操作

**聚簇索引的优势**

- **将索引和数据保存在一起，如果直接使用聚簇索引则避免了 IO**
- **使用覆盖索引的时候可以不需要回表**

**聚簇索引的劣势**

- **如果数据全部放在内存中，聚簇索引的访问顺序就没那么重要了**
- **可能产生回表操作**
- **插入速度依赖于插入顺序（如果按照逐渐的顺序插入则快，如果不是则会导致页分裂）**
- **聚簇索引造成全表扫描变慢（特别是因为行比较稀疏或者页分裂导致数据存储不连续的时候）**
- **更新聚簇索引的代价较高（InnoDB 会让被更新的行移动到对应的位置）**
- **二级索引（非聚簇索引）比想象的要大，因为其包含主键 id**

### 覆盖索引（Using Index）

**注意覆盖索引可以在一定时候进行优化 SQL**

**比如以下 SQL 的转换，在 ****`WHERE actor = 'SEAN CARREY' AND title LIKE '%APOLLO%'`**** 中能够过滤出较少结果集的情况的优化效果很明显，如果整个结果集过小或者结果集很多，则并不能达到优化**

```sql
// 对于通过使用覆盖索引进行优化
// 源 SQL, 这时候就需要回表查询
// 即 explain 之后是 using where condition
SELECT * FROM products WHERE actor = 'SEAN CARREY' AND title LIKE '%APOLLO%'
// 通过使用聚簇索引，这时候并不需要回表查询
// 即 explain 之后是 using where, using index
SELECT * FROM products 
  JOIN ( SELECT id FROM products WHERE actor = 'SEAN CARREY' AND title LIKE '%APOLLO%') AS temp
  ON products.id = temp.id
```

### 使用索引帮助排序

排序的时候 ORDER BY 并不一定的需要满足最左匹配原则，特别是

```sql
KEY index(rental_date, inventory_id, customer_id)
// SQL
SELECT rental_id, staff_id FROM rental WHERE rental_date = '2005-05-25' ORDER BY inventory_id, customer_id
```

### 冗余索引

**我们大多数时候都不要冗余索引（如：索引A：a；索引B：a,b）**

**但当一个索引很大的时候，维护他是比较困难的，这时候如果扩展已有的索引可能导致其变得更大（特别是有 VARCHAR 作为索引的时候），所以这时候可以通过添加一个新的索引来增加性能，但这样我们插入的时候就会变慢**

### 索引给锁的帮助

**索引能够让查询锁定更少的行**

**即：如果我的查询从不访问那些不需要的行，就会锁定更少的行（在存储引擎层过滤掉所有不需要的行的时候有效）**

```sql
SELECT id FROM actor WHERE id < 5 AND id != 1
```

**通过 Explain 可以看出这里需要锁小于 5 的所有行，并且在存储引擎层会返回所有小于 5 的再返回使用 Using Where 过滤**

## 表和索引的维护

### 索引维护

```sql
**// 一方面 存储引擎会每隔一段时间会进行重新统计（在首次打开、表的大小变化超过了 1/16 或者插入了 20 亿条）
// 另一方面我们也可以人工调用进行重新统计**
analyze table 
**// 查看查看索引的信息
// cardinality 表示存储引擎估算索引大概有多少个取值（通过抽样）**
SHOW INDEX FROM table
```

**碎片分类**

- **行碎片：数据行被存储在多个地方的多个片段中，访问一行需要访问多个片段**
- **行间碎片：逻辑上顺序的页，再次攀上不是顺序的**
- **剩余空间碎片：在数据页中有大量的剩余空间没有使用**

```sql
// 重新分配（类比导出导入）
OPTIMIZE TABLE
```

# MySQL 查询语句设计

## 优化数据访问

查询性能低下最基本的原因就是访问的数据太多了，又出现了不可避免的筛选大量数据的情况

根本原因在于

1. 确认应用程序是否在检索大量超过需求的数据
2. 确认 MySQL 服务器曾是否在分析大量超过需求的数据行

### 是否请求了不需要的数据

1. **查询了不需要的纪录**

```sql
SELECT .... LIMIT 10000,10
->
SELECT ...... 
INNER JOIN (SELECT id .... LIMIT M, N) temp ON ....
```
1. **多表关联的时候返回了所有的列 or 取出所有的列**

```sql
SELECT * FROM actor INNER JOIN ....
->
SELECT actor.*, film.name FROM actor INNER JOIN ...
```
1. **重复查询数据**
**如：有评论的地方需要查询用户头像 URL，在多次评论的时候就有多次查询**

### 是否扫描额外的记录

响应时间：注意服务时间和排队时间

扫描行数与返回行数：`explain` 中可以看到 `rows` 代表扫描的行数

```sql
SELECT * FROM actor WHERE film_id = 1 
```

**在有 film_id 索引和没有索引的情况下，扫描的行数会截然不同**

## 查询的重构

### 切分大查询

对于大查询，可能一次性会锁住很多数据、占满整个事务日志、阻塞其它查询，这个时候就要将大的语句拆分成小语句

```sql
**// 特别是对于一个大的 DELETE 要拆分成很多小的 DELETE 语句**
DELETE FROM message WHERE created_time < DATE_SUB(NOW, INTERVAL 3 MONTH)
**// -- 拆分--
int row_affected = 0;
do{
  row_affected = Dao.start("**DELETE FROM message WHERE created_time < DATE_SUB(NOW, INTERVAL 3 MONTH)**");
}while(row_affected > 0)**
```

### 拆分关联查询

拆分关联查询可以让缓存效率更高，查询分解之后也减少了锁的竞争，减少了冗余记录的查看，使用了 Hash 索引

但另一方面，如果关联查询的数量很多，就有可能造成有 `IN` 中有大量的值存在，减少了索引的效率

## 查询执行的流程

1. 客户端发送一条查询语句给服务端
2. （如果开启了）查询查询缓存
3. 经过解析器，将 SQL 解析为解析树
4. 预处理
5. 经过查询优化器，到达查询执行引擎
6. 通过 API 条用存储引擎进行查询，返回结果

### 通信协议

MySQL 通信协议是半双工的，一旦一段发出消息，只有等另一端返回

`show full processlist` 可以回显所有的链接的线程

- State 的状态
    - init: 创建
    - Sleep：等待客户端发来请求
    - Query：正在执行查询或将结果发送给客户端
    - Locked：正在等待表锁（行锁由 InnoDB 自己实现，所以不会体现）
    - Analyzing and statistics：正在收集存储引擎的统计信息
    - Copying to tmp table [on disk]：正在执行查询（并使用了临时表，如 GROUP BY、UNION）
    - Sorting result：排序

### 查询缓存

查询缓存现在已经关闭了，默认的是 MySQL 会有限查询这个缓存是否会命中缓存中的数据

### 优化

1. **解析 SQL**
**解析 SQL 将把 SQL 语句解析为一个解析树**
**检查是否有语法错误、关键字是否正确等**
2. **预处理**
**进一步检查是否合法，如检查数据列和数据表是否存在，是否存在歧义**
3. **优化 SQL 执行计划**
**一条查询可以有很多执行方式，最后都肯定会返回相同的结果，而优化器的作用就是找到其中最好的执行计划**
**常用优化类型**
    1. **静态优化：对解析树进行优化，如将简单的代数变化转换成等价的形式（编译时优化）**
    2. **动态优化：与查询上下文有关（运行时优化）**
    3. **重新定义关联表顺序**
    4. **尝试将外连接变为内连接（多表查询使用 WHERE）**
    5. **使用等价代换（规范、合并、减少表达式，去除恒成立）**
    6. **优化 ****`COUNT`****、****`MIN`****、****`MAX`**** 函数（使用一个常数代替，并随之移出表达式）**
    7. **预估并转换为常数表达式（将一些查询转换为常数）**
    8. **覆盖索引扫描**
    9. **子查询优化（减少子查询）**
    10. **提前终止无用查询（如某个查询已经返回了空集了）**
    11. **等值传播**

```sql
SELECT f.id FROM film f INNER JOIN film_actor fa ON fa.film_id = f.id WHERE f.id > 500 
// 优化结果
SELECT f.id FROM film f INNER JOIN film_actor fa ON fa.film_id = f.id WHERE f.id > 500 AND fa.film_id > 500
```
    1. **列表 IN 比较（将 IN 排序之后，再进行 二分查找）**

### 执行关联查询

**UNION 操作：将单个结果查询放在临时表内，然后在读出临时表数据进行 UNION 操作**

**OUTTER/LEFT/RIGHT JOIN：查询到一条数据，然后进行嵌套查询到另一张表**

**INNER JOIN：将一个表的查询结果放在临时表（派生表）中，之后再进行连接操作**

### 关联查询优化

**对于多层关联的查询，关联优化器会尝试在所有的关联顺序中找到一个成本最小的来**

**但是当表的数量增多的时候，关联顺序数量会以阶乘的速度增加，所以只能贪婪地搜索一个较优的结果**

1. **确保 ****`ON`**** 的列上有索引**
2. **确保 ****`GROUP BY`**** 、****`ORDER BY`**** 上的表达式只涉及到一个表中的列，并且有索引**

### 排序优化

当无法使用索引的时候，MySQL 就会使用内存排序或者文件排序（filesort）

**旧版本：使用两次传输排序，读取行指针和需要排序的字段，对其进行排序，之后根据排序结果读取所需要的行**

**新版本：使用单次传输排序，先查询到所需要的列，再根据给定的列进行排序，直接返回（只需要一次顺序 IO）**

### COUNT 优化

1. **只有在没有任何 ****`WHERE`**** 的 ****`COUNT`**** 在 MyISAM 下是非常快的**
2. **如果在不要求精度的情况下，可以使用 ****`SHOW TABLE STATUS`**** 使用近似值**

### GROUP BY 优化

**MySQL 会采取松紧索引扫描的方式进行，当然在无法使用索引的时候会使用 Temporary Table 或者 filesort**

1. **在能使用 PK 或者 Unique Index 的情况下就不要使用其他的标识列进行分组**

### LIMIT 优化

```sql
SELECT .... LIMIT M, N
```

**当 M 特别大的时候， MySQL 会搜索出来所有的 M+N，并抛弃掉 M**

1. **延迟关联**

```sql
SELECT ...... 
INNER JOIN (SELECT id .... LIMIT M, N) temp ON ....
```
1. **预估边界值**

```sql
SELECT ... WHERE ... BETWEEN P AND Q
```
1. **记录之前的 id 位置（不需要再抛弃，0 OFFSET）**

### UNION 优化

1. **只有在需要服务器消除重复的行的时候才使用 ****`UNIION ALL`**
2. **如果有需要，尽量将 ****`WHERE`****、****`LIMIT`****、****`ORDER BY`**** 手动向下推**

# MySQL 其他特性

## 分区

**MySQL 的分局即将表面是一个独立的逻辑表，底层实现是多个物理子表组成**

```sql
CREATE TABLE sales(
  order_date DATETIME NOT NULL,
  ...
) ENGINE=InnoDB PARTITION BY RANGE(YEAR(order_date))(
  PARTITION p_2010 VALUES LESS THAN (2010),
  PARTITION p_2011 VALUES LESS THAN (2011),
  PARTITION p_cur VALUES LESS THAN MAXVALUE);
```

**使用分区的场景**

1. **表非常大以至于无法全部放在内存中**
2. **表的最后部分有热点数据，而其他的都是历史数据**
3. **经常性的批量删除大量数据**
4. **索引使用率过高（如：InnoDB 单个索引互斥访问）**

**使用分区表的要求**

1. **最多 1024 个分区**
2. **分区表无法使用外键**
3. **分区表的主键或者唯一索引的列必须包含**

### 实现原理

**分区表由多个相关的底层表实现，底层表和普通表对于存储引擎来说是一样的，只是分区表的索引是在各个底层表上各自加了一个完全相同的索引**

**当进行操作的时候，分区表先锁住所有的底层表，然后释放需要过滤的分区表**

### **常用的分区策略**

1. **根据 PK 进行分区，减少 InnoDB 互斥量竞争**
2. **根据自己的业务需求进行分区（如根据星期几进行分区，这样就可以简单地返回周几的数据）**
3. **根据热点数据进行分区（将冷数据放在一起，热数据放在一起）**

### 分区的问题

1. 分区列和索引列不匹配的时候，可能造成要访问所有的分区（注意在关联的时候存在的这个问题）
2. 选择分区的成本可能很高（范围查询、符合查询条件的行的查询）
3. 打开并锁住所有底层表的成本可能很高
4. 维护分区的成本

## 视图

### 视图的实现

1. **合并算法（MERGE）**
**系统将用户 SQL 与视图 SQL 进行合并然后进行查询（即视图是没有实体的）**
2. **临时表算法（TEMPRABLE）**
**系统先执行视图 SQL，放在临时表中，然后再根据用户 SQL 去临时表中查询**

**当视图汇总含有 ****`GROUP BY`****、****`DISTINCT`****、聚合函数、****`UNION`****、子查询的时候，因无法建立一一对应关系，就会使用临时表算法**

可以通过 `EXPLAIN SELECT * FROM view_name` 查看使用的是临时表算法（DERIVED）还是合并算法（PRIMARY）

### 视图对性能的提升

**对于如 SQL Server 存在索引视图，那么是有提升的，但是并不是所有的视图都有索引视图**

1. **视图能够被分配聚簇索引，并存储临时结果（简单的视图不会有这个功能，但是索引视图有，即他们会将结果集存储在数据库的物理存储中）**
2. **视图索引在层数上也要也比表的索引简单**
如：我有一个 10000000 万条的数据表
**显而易见下面这个索引要比正常的数据表的 B+ 索引要小很多，当然速度也要快很多**

```sql
SELECT * FROM table_name WHERE country = "China"
```

## 外键约束

### 外键的成本与性能

1. **外键的修改都需要在另一张表中执行一次查找工作（即使是主键索引也需要）**
2. **外键在一些特殊场景（确保两个表有一致的数据、关联删除、关联更新）比在应用程序中检查高效**

## XA 事务

如果是分布式事务，则需要将 ACID 扩展到多个数据库之间，则需要一个 XA 事务进行参与

MySQL 有两种 XA 事务

1. 参与到外部的分布式事务中
2. 通过 XA 来协调存储引擎和二进制日志

### 内部 XA 事务

MySQL  本身的插件式框架导致其在内部需要使用 XA 事务

**内部 XA 事务会造成 MySQL 性能的快速下降，使得 MySQL 在事务提交的时候，不仅仅需要对 bin log 进行持久化操作，还需要通过 fsync 进行 InnoDB 事务日志的持久化操作**

### 外部 XA 事务

外部 XA 事务可以通过外部对事务进行支持，但由于可能的通信延迟和参与者本身失败，外部 XA 事务的消耗比内部更大

## 查询缓存

查询缓存目前已经是默认关闭的，是由于其成为了整个服务器的资源竞争单点，在多核服务器上还有可能出现僵尸

所以一般情况下我们都关闭查询缓存，或只分配大约几十兆的很小的的查询缓存空间

### 何时使用查询缓存

**MySQL 不会进行解析，只有符号、空格、注释等一摸一样的才有可能击中查询缓存**

**含有 ****`NOW()`**** 等不确定数据，甚至于任何临时表、系统表、 用户变量、存储过程的不会被缓存**

```sql
// 不能被缓存
DATE_SUB(CURRENT_DATE, INTERVAL 1 DAY)
// 可以被缓存
DATE_SUB('2007-07-14', INTERVAL 1 DAY)
```

### 查询缓存的内存结构

查询缓存全部存储在内存中

**MySQL 将用于查询缓存的内存分为一个个数据块，数据块是变长的，每个数据块都存储了自己的类型、大小、存储数据的本身，还外加指向前一个和后一个数据块的指针**

1. **当查询缓存需要空间的时候， MySQL 就会从空间申请一块数据块用于存储结果**
2. **之后锁住空间块，然后找到合适大小数据块（先申请一整块）

（由 query_cache_min_res_unit 决定，太小会导致频繁申请内存，太大会浪费空间）
（可以通过 $\dfrac{query\_cache\_size - Qcache\_free\_memoray}{Qcache\_queries\_in\_cache}$ 来查看平均查询大小，但前提是查询大小均匀）**
3. **选择一个尽量小的内存块，然后将数据存入其中**
4. **如果申请的内存空间还有剩余，MySQL 会直接对其释放（之后不用的再释放掉）**

**但是这样的操作在并发的时候就会产生碎片，导致这些碎片无法继续使用**

### 什么时候使用查询缓存

**需要消耗大量资源的查询（****`COUNT`****）、复杂的 SELECT 查询（多表 ****`JOIN`****+****`ORDER`****+****`LIMIT`****）、且极少存在 ****`UPDATE`****、****`DELETE`****、****`INSERT`**** 的时候适合用查询缓存**

MySQL 接到 SELECT 查询的时候，会更新 Qcahce_hits 和 Com_select， 即缓存命中率为$\dfrac{Qcache\_hits}{Qcache\_hits + Com\_select}$

使用时还有一些点需要注意：

1. 使用多个小表替代一个大表对查询缓存有好处（失效策略能在更细的粒度上进行）
2. 批量写入只做一次缓存失效
3. 缓存空间过大容易在过期操作的时候导致服务器僵死
4. 对于大部分表都可以直接禁止查询缓存

### 查询缓存的优化

1. **确认缓存命中率（更好的方式是禁用缓存观察性能，再打开缓存观察性能）**
2. **确认查询是否能被缓存（query_cache_limit）**
3. **确认是否有太多失效**
    1. **确认是否有碎片问题（检查平均大小）**
    2. **确认查询缓存的空间足够大（Qcache_free_memory）**
    3. **确认是否有太多****`UPDATE`****、****`DELETE`****、****`INSERT`****操作**
1. **确认是否预热**

### InnoDB 和查询缓存

InnoDB 因为还要实现 MVCC，所以在查询缓存方面的设计更加复杂，还会涉及到对于事务 ID 与数据 ID 的问题

# MySQL 服务器设计

# MySQL 操作系统设计

# MySQL 主从复制

Keep It Simple & Stupid：不要按照想象做事儿，

### 复制解决的问题

数据分布、备份、负载均衡、读写分离、高可用故障切换

## 复制的实现

1. **主库将数据更改记录在 Bin Log 中**
**每次准备提交事务完成之前,主库将把更新的事件记录记录到二进制日志中**
**记录之后，主库会告诉存储引擎可以提交事务了**
2. **从库开启 IO 线程读取 Bin Log 到从库的 Relay Log 中**
**IO 线程不会对 Bin Log 进行轮询，而会采用休眠 + 唤醒的机制**
3. **从库开启 SQL 线程读取 Relay Log 并更新数据**

### 复制方式

1. **ROW：通过记录行的变化**
2. **STATEMENT：通过记录语句的复制（直接将 SQL 语句进行复制）**
3. **MIX：混合**

**但无论哪种方式，都是通过主库上的 bin log，并且通过 relay log 的形式在主库和从库之间进行异步的数据复制**

### 基于语句的复制（STATEMENET）

**好处：速度极快，实现简单，二进制日志紧凑、允许二次修改**

**缺点：无法使用一个函数（UUID、CURRENT_USER 等）、更新必须是串行的（导致需要很多锁）、对于一些触发器、存储过程在复制过程中存在 Bug**

### 基于行的复制（ROW）

**好处：可以精准的复制行的信息、无须重放更新主库的查询的更新速度快、批量更新快**

**缺点：重放一些查询的代价比较高（即一些更新语句是需要查询的）、无法进行时间点恢复**

## 复制配置

### 冷启动

1. 创建复制账号
创建用户，并赋予从库对应的权限（如只能查，不能写等）

```sql
GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.*
TO repl@'192.168.0.%' IDENTIFIED BY 'password'
```
1. 配置主库和从库
在主库的 my.cnf 文件中修改 log_bin、server_id
在从库的 my.cnf 文件中修改 log_bin、server_id、relay_log、log_slave_updates、read_only
**log_slave_updates 表示是否允许将其重放的事件也记录在自身的二进制日志中（即允许多层复制）**
**如果不开启，则可能导致配置错误时，从库数据被修改**
2. 通知从库连接主库
**不要通过 my.cnf 配置主库，而要通过命令**
**然后可以通过 ****`SHOW SLAVE STATUS`**** 检查复制是否正确运行**

```sql
CHANGE MASTER TO MASTER_HOT = 'server1',
MASTER_USER='repl',
MASTER_PASSWORD='password',
MASTER_LOG_FILE='mysql-bin.0000001',
MASTER_LOG_POS=0； // 日志从 0 开始读
```

### 热启动

热启动相较于冷启动，需要的三个条件

1. 在某个时间点主库的数据快照
2. 主库当前的二进制文件，和对应的日志文件偏移量
3. 快从快找到现在的二进制日志

所以从其他服务器拷贝而来的方法对应的有：

1. 冷备份：关闭主库 → 复制 → `CHANGE MASTER TO` → 启动主库与从库
2. 热备份：如果仅仅使用 MyISAM 则可以使用 `mysqlhotcopy` 或 `rsync` 进行复制
3. mysqldump：如果仅仅使用 InnoDB 则可以使用 `mysqldump` 备份到从库
4. 快照或备份：如果 Bin Log 都存在则可以直接使用
5. Percona Xtrabackup

## 复制拓扑结构

### 一主多从结构

**在针对少量读、大量写的环境中，一主多从结构特别适合，即能够做到读写分离**

同时，还可以添加不同的索引、存储引擎、数据备份、容灾、为测试、开发使用

### 双主结构下的双主结构

**主主结构多半适用于场景（不同地理位置的办公室需要一份可写的数据拷贝）**

这样的最大问题是解决冲突，如同时修改一行或者包含 AUTO_INCREMENT

**虽然 MySQL 增加了 auto_increment_increment 和 auto_increment_offset 让同时写变得安全了点，让 MySQL 在 INSERT 的时候选择不冲突的值但依旧很危险**

### 主被结构下的双主结构

**主被结构在默认的情况下是主从复制结构，但是不同的是，他们的服务器配置是对称的**

**即当我们执行 ALTER TABLE 的时候可能锁住整个表，这个时候就可以将主从服务器的功能进行交换，然后再进行 ALTER TABLE，之后再换回来**

配置流程

1. 确保两台服务器上有相同的数据
2. 启动二进制日志，选择唯一的服务器 ID，创建复制账号
3. 启动备库的更新的日志记录（故障转移和故障恢复的关键）
4. 把被动服务器配置为只读
5. 启动每个服务器的 MySQL实例
6. 将每个主库设置为对方的从库，使用新创建的二进制日志开始工作

### 拥有备库的双主结构

增加冗余结构

### 环形结构

NOPE！

### 分发主库结构

当从库很多的时候，会对主库有很大的负载

**这个时候当从库有个大的事件，如 ****`LOAD DATA INFILE`**** 操作，就可能导致主库负载明显上升，崩溃**

**这个时候通过一个采用 blackhole 存储引擎的分发主库，分发主库作为主库的从库，分发主库再管理真正的从库**

**分发主库唯一的目的就是提取并获取主库的二进制日志，然后连接分发主库，为原来的主库带来负担，并且使用 blackhole 避免在分发主库上做查询**

### 金字塔结构

## 复制和容量规划

**复制只能扩展读操作，不能扩展写操作**

**因为所有的从库迟早都要经过写，而读是可以分发到从库的**

双主拓扑结构的貌似能够实现 50% 的串行化写入，但其实这样比单台机器的 100%  并发写入还慢

### 从库延迟

1. 短时间内的尖刺：负载过大，从库短时间内跟不上主库
2. 宽而高的水平线、从库的上升角度变平：从库接近耗尽从库的容量

### 测量从库延迟

`SHOW SLAVE STATUS` 输出的 Seconds_behind_master 可以从理论上显示从库的延迟

但是 second_behind_master 不是精准的，其实通过将当前服务器的时间戳与二进制日志的事件的时间戳比较的而得的，但如果遇到大事务、从库线程正在运行、分发主库落后了，就会产生问题

**更好的方法是直接通过 heartbeat record，通过将从库的时间戳减去主库的 heartbeat record 记录来计算延迟**

## 复制的问题与解决方案

### 数据丢失或损坏

1. **主库意外关闭：指定从库从下一个二进制日志的开头开始读数据**
**（主库如果没有设置 sync_binlog 则有可能导致崩溃前最后几个二进制日志刷新到磁盘中）**
2. **从库意外关闭：由于从库重启的时候会自动读取 **[**master.info**](http://master.info)** 确认上次复制的位置，但很有可能由于文件没有同步到磁盘，文件中的信息是错误的，而重新执行二进制日志可能导致唯一索引错误，所以需要使用 pt-slave-restart**
3. **主库上二进制文件损坏：只有忽略损坏并使用 flush logs 重新开启一个日志文件，并将从库指向该文件**
4. **从库上二进制文件损坏：通过 CHANGE MASETER TO 丢弃并重新获取（MySQL 5.5+ 能自动重新获取）**
5. **InnoDB 日志和二进制日志不同步：使用 sync_binlog，否则没有方法**

### 非事务性表的损坏

比如更新 MyISAM 表的 100 个数，更新到 50 条的时候崩溃了，这时候从库会更新更新完 100 条数据，MySQL 随后就会在主库上，之后 MySQL 会在主库上发现问题，而在从库上没有报错，就会发生错误并中断

### 事务性表的损坏

事务性存储引擎，只有在事务提交之后，才会将其记录在二进制日志中，如果事务回滚，MySQL 就不会记录这条查询，也就不会在从库上重放

### 不确定语句

**对于带 LIMIT 的 UPDATE 语句的更新操作取决于查询行的顺序，而主库和从库中可能有顺序不一致**

**所以在 STATEMENT 的情况下，禁止使用带 LIMIT 的 UPDATE 语句**

## 半同步复制

**当提交事务的时候，客户端接收到查询结束反馈前必须保证二进制日志至少已经传输到一个从库上**

即主库提交事务之后，就开始等待从库执行事务并反馈给主库，然后再反馈给客户端

# MySQL 集群

## 数据扩展

### 数据分片

**即不同节点执行不同的任务，一个 WEB 服务器连接多个 MySQL 数据库，不同数据库存放不同的数据（如：门户网站存新闻数据库、论坛数据库等）**

**优点：简单、高效**

**缺点：无法无限进行扩展，如果一个功能区被绑定在同一 MySQL 节点，则只能进行垂直扩展，造成扩展性设计紊乱**

### 选择分区键

分片最大的挑战在于如何进行分片

**原则：对最重要并且频繁查询的数据减少分片（避免不同节点的交互）**

**MySQL NDB Cluster：根据主键 Hash 值来分割（其实不太好，因为可扩展性不强**

![](https://secure2.wostatic.cn/static/mQrBCtHfKmzmBANqNa5hF3/image.png)



## MySQL 集群

### MySQL NDB Cluster

NDB 是一个非常复杂的数据库，分布式、具有容错性、 非共享、提供同步复制、节点数据自动分片的数据库

优点：超高的写入和按 key 查询吞吐量

### Clustrix

### ScaleBase

### GenieDB

### Akiban

## 负载均衡

可扩展性、高效性、可用性、透明性、一致性

### 主库与从库读分离

1. **基于查询分离（不得容忍脏数据的到主库，可以容忍的到从库）**
2. **基于会话分离（用户自己修改了数据的到主库，没有修改自己的数据的到从库）（甚至可以 5s 内修改了数据的）**
3. **基于版本分离（跟踪对象的版本号，版本号高的到主库，版本号低额到从库）**

### 从库读分离

1. **随机**
2. **轮询**
3. **最少连接数（分配给最少活跃链接的服务器）**
4. **最快响应**
5. **哈希**
6. **权重**

# MySQL 高可用

## 宕机的原因

1. **运行环境宕机（操作系统、硬盘、网络）**
    1. **磁盘耗尽**
1. **性能问题**
    1. **糟糕的 SQL**
    2. **糟糕的表和索引设计**
1. **复制问题**
    1. **主从复制不一致**
1. **数据丢失或损坏**
    1. **DROP TABLE 等误操作**

# MySQL 备份

# Explain 解释

Explain 并不是不会执行，他会对 FROM 中的数据进行子查询，才能完成外层查询优化

**但是 Explain 的结构依旧是金丝结果，大多数时候都是比较精确地，但有时候也会有影响**

## Explain 的局限

1. **Explain 不支持触发器、存储过程、UDF**
2. **Explain 不显式关于查询的执行计划的所有信息**
3. **Explain 不区分具有相同名字的事物（内存排序和文件排序都用 filsort、磁盘和内存的临时表都用 Using temporary）**
4. Explain 只能解释 SELECT 语句，对于 INSERT、`UPDATE`、`DELETE` 不能进行解释

## Explain 中的列

### ID

**每一列总是包含一个编号的，表示唯一的语句**

**Explain 会将所有的子查询、派生表（****`FROM`**** 中的子查询）、****`UNION`**** 查询 都提出来作为单独的一行**

### SELECT TYPE

1. **SUBQUERY：子查询**
2. **DERIVED：派生表（****`FROM`**** 中的子查询）**
3. **UNION：****`UNION`**** 中第二个或之后的会被作为 UNION**
4. **UNION RESULT：****`UNION`**** 中作为结果集的 ****`SELECT`**

### TABLE

**访问的表名或别名，有多个表则显示多个行（并根据 JOIN 的左侧深度优先树来进行排序）**

### TYPE

1. **ALL：全表扫描**
2. **INDEX：根据索引扫描**
3. **RANGE：有限制的索引扫描**
4. **REF：使用索引访问**
5. **EQ_REF：使用索引访问并保证只返回一行**
6. **CONST、SYSTEM：常量**
7. **NULL：不需要访问表**

### **POSSIBALE_KEY**

**可以使用的索引（根据访问的列和对应的比较操作符）**

### KEY

使用了哪些索引来优化访问

```sql
EXPLAIN SELECT actor_id, film_id FROM film_actor
************************************************
id:1
select_type:SIMPLE
table:film_actor
type:index
possible_key:NULL
key:idx_fk_film_id
key_len:2
ref:NULL
rows:5143
Extra:Using index
```

**可以看到，我们查询是无法走索引的，但是因为可以通过覆盖索引的方式最小化查询成本，而使用索引**

### KEY_LEN

MySQL 在索引中使用的字节数（即需要用到索引中多长的内容的对应的字节数）

### REF

ref 代表了之前的表再 key 对应索引查找值或常数

```sql
EXPLAIN SELECT f.film_id FROM film 
INNER JOIN film_actor ON film.film_id = film_actor.film_id AND film_actor_id = 1
+----------+-------------------+---------------------+
|   table  | key               | ref                 |
+----------+-------------------+---------------------+
| ...      | ....              | ...                 |
+----------+-------------------+---------------------+
|film_actor| PRIMARY           | const, film.film_id |
+----------+-------------------+---------------------+
```

### ROW

找到所需的行遍历的行数（但其实也是估算的）

### EXTRA

1. Using index：使用了覆盖索引
2. Using where：搜索结果之后在存储引擎层进行了过滤
3. Using temporary：对查询结果排序时使用了临时表
4. Using filesort：使用了外部索引排序，而没有按照次序读取
5. Range check for each record(index map: N)：没有好用的缩阴，新的索引将在连接的每一行上重新估算



